import {
  BadRequestException,
  Injectable,
  Logger,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../../config/prisma.service';
import * as bcrypt from 'bcrypt';
import { Login } from '../dto/login.dto';
import { UserService } from '../../user/services/user.service';
import { Fido2Lib } from 'fido2-lib';

import { User } from 'src/user/models/user';
import { makeUUID } from 'src/utilities/utils';
import { randomBytes } from 'crypto';
import { generateChallenge } from '../../utilities/utils';
import { Challenge } from '../dto/challenge';
import { VerifyDTO } from '../dto/verifyDto';

import * as fs from 'fs';
import * as crypto from 'crypto';
import { RegistrationEncoded } from '@passwordless-id/webauthn/dist/esm/types';
import { SuccessResponse } from '../../utilities/successResponse';

@Injectable()
export class AuthenticationService {
  constructor(
    private readonly userService: UserService,
    private prismaService: PrismaService,

    private jwtService: JwtService,
  ) {}

  logger = new Logger(AuthenticationService.name);
  async getChallenge() {
    const nonce = generateChallenge();
    const challenge: Challenge = { challenge: nonce };
    return await this.prismaService.challenge.create({
      data: challenge,
    });
  }

  async register(publicKey, user) {
    const registration: RegistrationEncoded = {
      username: 'Arnaud',
      credential: {
        id: '3924HhJdJMy_svnUowT8eoXrOOO6NLP8SK85q2RPxdU',
        publicKey:
          'MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEgyYqQmUAmDn9J7dR5xl-HlyAA0R2XV5sgQRnSGXbLt_xCrEdD1IVvvkyTmRD16y9p3C2O4PTZ0OF_ZYD2JgTVA==',
        algorithm: 'ES256',
      },
      authenticatorData:
        'SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2NFAAAAAAiYcFjK3EuBtuEw3lDcvpYAIN_duB4SXSTMv7L51KME_HqF6zjjujSz_EivOatkT8XVpQECAyYgASFYIIMmKkJlAJg5_Se3UecZfh5cgANEdl1ebIEEZ0hl2y7fIlgg8QqxHQ9SFb75Mk5kQ9esvadwtjuD02dDhf2WA9iYE1Q=',
      clientData:
        'eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiYTdjNjFlZjktZGMyMy00ODA2LWI0ODYtMjQyODkzOGE1NDdlIiwib3JpZ2luIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwIiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ==',
    };
    try {
      //   const registrationParsed = await server.verifyRegistration(
      // registration,
      // expected,
      //   );
      const key = JSON.stringify(registration.credential);
      this.prismaService.user.update({
        where: {
          email: registration.username,
        },
        data: {
          biomertricKey: key,
        },
      });
    } catch (error) {
      this.logger.log(error.message);
      throw new BadRequestException();
    }
    return new SuccessResponse();
  }

  async verfiyRegister(verifyDto: VerifyDTO) {
    // const challenge = verifyDto.challenge;
    // let id;
    // const ChallengePayload = await this.prismaService.challenge.findUnique({
    //     where: {

    //       }
    //   }
    // });

    const credentialKey = {
      // obtained from database by looking up `authentication.credentialId`
      id: '3924HhJdJMy_svnUowT8eoXrOOO6NLP8SK85q2RPxdU',
      publicKey:
        'MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEgyYqQmUAmDn9J7dR5xl-HlyAA0R2XV5sgQRnSGXbLt_xCrEdD1IVvvkyTmRD16y9p3C2O4PTZ0OF_ZYD2JgTVA==',
      algorithm: 'ES256',
    } as const;
    const expected = {
      challenge: '56535b13-5d93-4194-a282-f234c1c24500', // whatever was randomly generated by the server.
      origin: 'http://localhost:8080',
      userVerified: true, // should be set if `userVerification` was set to `required` in the authentication options (default)
      counter: 123, // Optional. For device-bound credentials, you should verify the authenticator "usage" counter increased since last time.
    };
    // const authenticationParsed = await server.verifyAuthentication(
    //   authentication,
    //   credentialKey,
    //   expected,
    // );

    return '';
  }

  verifySignature(
    signedDataPath: string,
    signaturePath: string,
    publicKeyPath: string,
  ): boolean {
    // Read the signed data, signature, and public key
    const signedData = fs.readFileSync(signedDataPath, 'utf-8');
    const signature = fs.readFileSync(signaturePath, 'base64');
    const publicKey = fs.readFileSync(publicKeyPath, 'utf-8');

    // Create a verifier object
    const verifier = crypto.createVerify('sha256');

    // Provide the signed data to the verifier
    verifier.update(signedData);

    // Verify the signature with the public key
    const isVerified = verifier.verify(publicKey, signature, 'base64');

    return isVerified;
  }
  /**
   *
   * @param loginDto
   * @returns {User}
   */
  async loginWithPassword(loginDto: Login): Promise<{}> {
    const user = await this.userService.findByEmail(loginDto.email);

    if (!user) {
      throw new NotFoundException('Password or email incorrect');
    }

    const isPasswordValid = await bcrypt.compare(
      loginDto.password,
      user.password,
    );

    if (!isPasswordValid) {
      throw new UnauthorizedException('Password or email incorrect');
    }
    const token = await this.generateToken(user);
    delete user.biomertricKey;
    delete user.password;
    const userData = {
      ...user,
      accessToken: token.accessToken,
      refreshToken: token.refreshToken,
    };
    console.log(token);

    return userData;
  }
  /**
   *
   * @param user
   * @returns {Object}
   */
  public async generateToken(user: User) {
    const payload: {} = { sub: user.id, username: user.email };
    const accessToken = this.jwtService.sign(payload);

    const refreshToken = this.jwtService.sign({ payload, accessToken });

    return { accessToken, refreshToken };
  }
}
