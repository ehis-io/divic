// import { BadRequestException, Injectable, Logger } from '@nestjs/common';
// // import { server } from '@passwordless-id/webauthn';
// import { RegistrationEncoded } from '@passwordless-id/webauthn/dist/esm/types';
// import { PrismaService } from 'src/config/prisma.service';
// import { SuccessResponse } from 'src/utilities/successResponse';
// import { generateChallenge } from 'src/utilities/utils';
// import { Challenge } from '../dto/challenge';
// import { VerifyDTO } from '../dto/verifyDto';

// import * as fs from 'fs';
// import * as crypto from 'crypto';

// @Injectable()
// export class Fido2Service {
//   constructor(private readonly prismaService: PrismaService) {}
//   logger = new Logger(Fido2Service.name);

//   async getChallenge() {
//     const nonce = generateChallenge();
//     const challenge: Challenge = { challenge: nonce };
//     return await this.prismaService.challenge.create({
//       data: challenge,
//     });
//   }

//   async register(expected) {
//     const registration: RegistrationEncoded = {
//       username: 'Arnaud',
//       credential: {
//         id: '3924HhJdJMy_svnUowT8eoXrOOO6NLP8SK85q2RPxdU',
//         publicKey:
//           'MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEgyYqQmUAmDn9J7dR5xl-HlyAA0R2XV5sgQRnSGXbLt_xCrEdD1IVvvkyTmRD16y9p3C2O4PTZ0OF_ZYD2JgTVA==',
//         algorithm: 'ES256',
//       },
//       authenticatorData:
//         'SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2NFAAAAAAiYcFjK3EuBtuEw3lDcvpYAIN_duB4SXSTMv7L51KME_HqF6zjjujSz_EivOatkT8XVpQECAyYgASFYIIMmKkJlAJg5_Se3UecZfh5cgANEdl1ebIEEZ0hl2y7fIlgg8QqxHQ9SFb75Mk5kQ9esvadwtjuD02dDhf2WA9iYE1Q=',
//       clientData:
//         'eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiYTdjNjFlZjktZGMyMy00ODA2LWI0ODYtMjQyODkzOGE1NDdlIiwib3JpZ2luIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwIiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ==',
//     };
//     try {
//       //   const registrationParsed = await server.verifyRegistration(
//       // registration,
//       // expected,
//       //   );
//       const key = JSON.stringify(registration.credential);
//       this.prismaService.user.update({
//         where: {
//           email: registration.username,
//         },
//         data: {
//           biomertricKey: key,
//         },
//       });
//     } catch (error) {
//       this.logger.log(error.message);
//       throw new BadRequestException();
//     }
//     return new SuccessResponse();
//   }

//   async verfiyRegister(verifyDto: VerifyDTO) {
//     // const challenge = verifyDto.challenge;
//     // let id;
//     // const ChallengePayload = await this.prismaService.challenge.findUnique({
//     //     where: {

//     //       }
//     //   }
//     // });
//     const credentialKey = {
//       // obtained from database by looking up `authentication.credentialId`
//       id: '3924HhJdJMy_svnUowT8eoXrOOO6NLP8SK85q2RPxdU',
//       publicKey:
//         'MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEgyYqQmUAmDn9J7dR5xl-HlyAA0R2XV5sgQRnSGXbLt_xCrEdD1IVvvkyTmRD16y9p3C2O4PTZ0OF_ZYD2JgTVA==',
//       algorithm: 'ES256',
//     } as const;
//     const expected = {
//       challenge: '56535b13-5d93-4194-a282-f234c1c24500', // whatever was randomly generated by the server.
//       origin: 'http://localhost:8080',
//       userVerified: true, // should be set if `userVerification` was set to `required` in the authentication options (default)
//       counter: 123, // Optional. For device-bound credentials, you should verify the authenticator "usage" counter increased since last time.
//     };
//     // const authenticationParsed = await server.verifyAuthentication(
//     //   authentication,
//     //   credentialKey,
//     //   expected,
//     // );

//     return '';
//   }

//   verifySignature(
//     signedDataPath: string,
//     signaturePath: string,
//     publicKeyPath: string,
//   ): boolean {
//     // Read the signed data, signature, and public key
//     const signedData = fs.readFileSync(signedDataPath, 'utf-8');
//     const signature = fs.readFileSync(signaturePath, 'base64');
//     const publicKey = fs.readFileSync(publicKeyPath, 'utf-8');

//     // Create a verifier object
//     const verifier = crypto.createVerify('sha256');

//     // Provide the signed data to the verifier
//     verifier.update(signedData);

//     // Verify the signature with the public key
//     const isVerified = verifier.verify(publicKey, signature, 'base64');

//     return isVerified;
//   }
// }
